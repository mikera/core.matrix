<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clojure.core.matrix.select documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Core.matrix</span> <span class="project-version">0.44.0</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3"><a href="clojure.core.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.implementations.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>implementations</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.linear.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linear</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-4 branch current"><a href="clojure.core.matrix.select.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-4"><a href="clojure.core.matrix.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.core.matrix.select.html#var-calc"><div class="inner"><span>calc</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-end"><div class="inner"><span>end</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-even"><div class="inner"><span>even</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-exclude"><div class="inner"><span>exclude</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-irange"><div class="inner"><span>irange</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-odd"><div class="inner"><span>odd</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-sel"><div class="inner"><span>sel</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-set-sel"><div class="inner"><span>set-sel</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-set-sel.21"><div class="inner"><span>set-sel!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-where"><div class="inner"><span>where</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.select.html#var-where-slice"><div class="inner"><span>where-slice</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clojure.core.matrix.select</h1><div class="doc"><pre class="plaintext">Namespace for fully featured core.matrix select API.

Supports selection functions, which are defined as:
   (fn [array dim] ...) =&gt; set of indices for dimension </pre></div><div class="public anchor" id="var-calc"><h3>calc</h3><div class="usage"><code>(calc f &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-end"><h3>end</h3><div class="usage"><code>(end a dim)</code></div><div class="doc"><pre class="plaintext">selector function for sel. selects the last valid index
</pre></div></div><div class="public anchor" id="var-even"><h3>even</h3><div class="usage"><code>(even a dim)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
selects all valid even indices</pre></div></div><div class="public anchor" id="var-exclude"><h3>exclude</h3><div class="usage"><code>(exclude idx)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
selects all valid indices except the ones specified in idx. idx can be a
number, a set or a sequence of indices</pre></div></div><div class="public anchor" id="var-irange"><h3>irange</h3><div class="usage"><code>(irange)</code><code>(irange end)</code><code>(irange start end)</code><code>(irange start end step)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
index-range selects the range from start position until (including!) the end
position. Also supports selector functions as arguments
Example: (sel [0 1 2 3 4] (irange 1 end)) ;=&gt; [1 2 3 4]
(irange) is the same as (irange 0 end)</pre></div></div><div class="public anchor" id="var-odd"><h3>odd</h3><div class="usage"><code>(odd a dim)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
selects all valid odd indices</pre></div></div><div class="public anchor" id="var-sel"><h3>sel</h3><div class="usage"><code>(sel a &amp; args)</code></div><div class="doc"><pre class="plaintext">matlab-like array indexing.
Like clojure.core.matrix/select but also supports selector functions:
 (sel [[1 2][3 4]] (irange) (irange));=&gt; [[1 2][3 4]]
 (sel [[1 2][3 4]] end end) ;=&gt; 4
 (sel [[1 2][3 4]] (exclude 1) (exclude 0)) ;=&gt; 2
 if only one argument is supplied it does linear indexing - selects the
 elements by their position in eseq.
 (sel [[1 2][3 4]] [0 3]) ;=&gt; [1 4]
 sel supports logical indexing:
 (sel [[-1 0][1 2]] (where pos?)) ;=&gt; [1 2]</pre></div></div><div class="public anchor" id="var-set-sel"><h3>set-sel</h3><div class="usage"><code>(set-sel a &amp; args)</code></div><div class="doc"><pre class="plaintext">like sel but sets the values of a at the selected indices to the supplied
values. Leaves a unchanged, returns the modified array. Examples:
(sel-set [[1 2][3 4]] 0 0 2) ;=&gt; [[2 2][3 4]]
(sel-set [[1 2][3 4]] (irange) 0 [[5][6]] ;=&gt; [[5 2][6 4]]
(sel-set [[1 2][3 4]] (irange) (irange) 1) ;=&gt; [[1 1][1 1]]
(sel-set [[-2 -1][0 1]] (where neg?) 0) ;=&gt; [[0 0][0 1]]</pre></div></div><div class="public anchor" id="var-set-sel.21"><h3>set-sel!</h3><div class="usage"><code>(set-sel! a &amp; args)</code></div><div class="doc"><pre class="plaintext">like set-sel but destructively modifies a in place
</pre></div></div><div class="public anchor" id="var-where"><h3>where</h3><div class="usage"><code>(where pred?)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
Enables logical indexing. Selects all indices where pred? succeeds.
Can only be used as second argument to sel. example:
(sel (range 10) (where (partial &gt; 5))) ;=&gt; [0 1 2 3 4]</pre></div></div><div class="public anchor" id="var-where-slice"><h3>where-slice</h3><div class="usage"><code>(where-slice pred?)</code></div><div class="doc"><pre class="plaintext">selector function for sel.
Selects all indices where pred? returns true when called against the respecitive slice on the given dimension
Can only be used as second argument to sel. example:
(sel [1 2 3 -1 -1 4 5 6] (where-slice pos?)) ;=&gt; [1 2 3 4 5 6]</pre></div></div></div></body></html>